using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace Refbesh.CastBesh.SourceGenerator;

[Generator]
public class CastOperatorGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes with CastableTo or CastableFrom attributes
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsCandidateClass(s),
                transform: static (ctx, _) => GetClassToGenerate(ctx))
            .Where(static m => m is not null);

        // Generate source for each class
        context.RegisterSourceOutput(classDeclarations, static (spc, source) => Execute(source!, spc));
    }

    private static bool IsCandidateClass(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclaration
            && classDeclaration.AttributeLists.Count > 0;
    }

    private static ClassToGenerate? GetClassToGenerate(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);

        if (classSymbol == null)
            return null;

        var castableToTargets = ImmutableArray.CreateBuilder<string>();
        var castableFromSources = ImmutableArray.CreateBuilder<string>();
        bool hasAttribute = false;

        foreach (var attribute in classSymbol.GetAttributes())
        {
            var attributeName = attribute.AttributeClass?.Name;

            if (attributeName == "CastableToAttribute")
            {
                hasAttribute = true;
                if (attribute.ConstructorArguments.Length > 0)
                {
                    var typeArg = attribute.ConstructorArguments[0];
                    if (typeArg.Value is INamedTypeSymbol targetType)
                    {
                        castableToTargets.Add(targetType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                    }
                }
            }
            else if (attributeName == "CastableFromAttribute")
            {
                hasAttribute = true;
                if (attribute.ConstructorArguments.Length > 0)
                {
                    var typeArg = attribute.ConstructorArguments[0];
                    if (typeArg.Value is INamedTypeSymbol sourceType)
                    {
                        castableFromSources.Add(sourceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                    }
                }
            }
        }

        if (!hasAttribute)
            return null;

        bool isPartial = classDeclaration.Modifiers.Any(m => m.ValueText == "partial");

        return new ClassToGenerate(
            classSymbol.ContainingNamespace.ToDisplayString(),
            classSymbol.Name,
            classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            castableToTargets.ToImmutable(),
            castableFromSources.ToImmutable(),
            isPartial
        );
    }

    private static void Execute(ClassToGenerate classToGenerate, SourceProductionContext context)
    {
        if (!classToGenerate.IsPartial)
        {
            // TODO: Report diagnostic that class must be partial
            return;
        }

        var sourceCode = GenerateCastOperators(classToGenerate);
        context.AddSource($"{classToGenerate.ClassName}_CastOperators.g.cs", sourceCode);
    }

    private static string GenerateCastOperators(ClassToGenerate classInfo)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using Refbesh.CastBesh.Casting;");
        sb.AppendLine();
        sb.AppendLine($"namespace {classInfo.Namespace}");
        sb.AppendLine("{");
        sb.AppendLine($"    public partial class {classInfo.ClassName}");
        sb.AppendLine("    {");

        // Generate CastableTo operators (this type -> other types)
        foreach (var targetType in classInfo.CastableToTargets)
        {
            var targetTypeName = ExtractTypeName(targetType);
            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Explicit cast operator from {classInfo.ClassName} to {targetTypeName}");
            sb.AppendLine($"        /// </summary>");
            sb.AppendLine($"        public static explicit operator {targetType}({classInfo.FullClassName} source)");
            sb.AppendLine("        {");
            sb.AppendLine($"            return global::Refbesh.CastBesh.Casting.CastEngine.Cast<{classInfo.FullClassName}, {targetType}>(source);");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        // Generate CastableFrom operators (other types -> this type)
        foreach (var sourceType in classInfo.CastableFromSources)
        {
            var sourceTypeName = ExtractTypeName(sourceType);
            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Explicit cast operator from {sourceTypeName} to {classInfo.ClassName}");
            sb.AppendLine($"        /// </summary>");
            sb.AppendLine($"        public static explicit operator {classInfo.FullClassName}({sourceType} source)");
            sb.AppendLine("        {");
            sb.AppendLine($"            return global::Refbesh.CastBesh.Casting.CastEngine.Cast<{sourceType}, {classInfo.FullClassName}>(source);");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string ExtractTypeName(string fullTypeName)
    {
        // Remove "global::" prefix if present
        fullTypeName = fullTypeName.Replace("global::", "");

        var lastDot = fullTypeName.LastIndexOf('.');
        return lastDot >= 0 ? fullTypeName.Substring(lastDot + 1) : fullTypeName;
    }
}
